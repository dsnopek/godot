<?xml version="1.0" encoding="UTF-8" ?>
<class name="NetworkedMultiplayerCustom" inherits="NetworkedMultiplayerPeer" version="3.6" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../class.xsd">
	<brief_description>
		A [NetworkedMultiplayerPeer] implementation that can be controlled from a script.
	</brief_description>
	<description>
		A [NetworkedMultiplayerPeer] implementation that can be used as a [member MultiplayerAPI.network_peer] and controlled from a script.
		Its purpose is to allow adding a new backend for the high-Level multiplayer API without needing to use GDNative.
		Here's a short example, assuming you have an imaginary [code]_connect_to_real_multiplayer()[/code] function that will create a client connected to the underlying multiplayer transport (ex. Steam peer-to-peer, PlayFab, etc):
		[codeblocks]
		[gdscript]
		extends Node

		var custom_peer := NetworkedMultiplayerCustom.new()
		var real_multiplayer_client

		func join_multiplayer():
		    custom_peer.set_connection_status(NetworkedMultiplayerPeer.CONNECTION_CONNECTING)
		    get_tree().network_peer = custom_peer

		    # Start connecting via real transport (ex. Steam peer-to-peer, PlayFab, etc).
		    real_multiplayer_client = _connect_to_real_multiplayer()
		    real_multiplayer_client.connect("connection_succeeded", self, "_on_real_multiplayer_connection_succeeded")
		    real_multiplayer_client.connect("connection_failed", self, "_on_real_multiplayer_connection_failed")
		    real_multiplayer_client.connect("peer_connected", self, "_on_real_multiplayer_peer_connected")
		    real_multiplayer_client.connect("peer_disconnected", self, "_on_real_multiplayer_peer_disconnected")
		    real_multiplayer_client.connect("recieved_message", self, "_on_real_multiplayer_received_message")

		    # Intercept any RPC's sent locally.
		    custom_peer.connect("packet_generated", self, "_on_custom_peer_packet_generated")

		func _on_real_multiplayer_connection_succeeded():
		    # Once connection is formed, assign a peer id somehow. If the real transport
		    # doesn't have a compatible id, you'll need to generate your own ids, and map
		    # them to the ids used by the real transport (the same mapping should be used
		    # by all peers).
		    #
		    # Also, if you want Godot to treat this peer as the "host" or "server" (per
		    # `get_tree().is_network_server()`) then use the peer id of 1.
		    var my_id = real_multiplayer_client.get_my_id()
		    custom_peer.initialize(my_id)
		    custom_peer.set_connection_status(NetworkedMultiplayerCustom.CONNECTION_CONNECTED)

		func _on_real_multiplayer_connection_failed():
		    custom_peer.set_connection_status(NetworkedMultiplayerCustom.CONNECTION_DISCONNECTED)

		func _on_real_multiplayer_peer_connected(peer_id):
		    # Let Godot know a peer connected. Again, you may need to map between Godot ids
		    # and the ids used by the real multiplayer client.
		    custom_peer.emit_signal("peer_connected", peer_id)

		func _on_real_multiplayer_peer_disconnected(peer_id):
		    # Same notes as above.
		    custom_peer.emit_signal("peer_disconnected", peer_id)

		func _on_custom_peer_packet_generated(peer_id, buffer, transfer_mode):
		    # Send any packets generated locally (ex RPCs) to the requested peer
		    # using the real multiplayer client.
		    if transfer_mode == NetworkedMultiplayerPeer.TRANSFER_MODE_RELIABLE:
		        real_multiplayer_client.send_reliable(peer_id, {
		            'from_peer_id': custom_peer.get_unique_id(),
		            'data': buffer,
		        })
		    else:
		        real_multiplayer_client.send_unreliable(peer_id, {
		            'from_peer_id': custom_peer.get_unique_id(),
		            'data': buffer,
		        })

		func _on_real_multiplayer_received_message(message):
		    # Take any packets we recieved from other peers, and deliver them locally.
		    custom_peer.deliver_packet(message['data'], message['from_peer_id'])
		[/gdscript]
		[csharp]
		using Godot;
		public class CustomLobby : Node
		{
		    NetworkedMultiplayerCustom customPeer;
		    RealMultiplayerClient realMultiplayerClient;
		    void JoinMultiplayer()
		    {
			customPeer.SetConnectionStatus(NetworkedMultiplayerPeer.CONNECTION_CONNECTING);
			GetTree().NetworkPeer = customPeer;
			// Start connecting via real transport (ex. Steam peer-to-peer, PlayFab, etc).
			realMultiplayerClient = _ConnectToRealMultiplayer();
			realMultiplayerClient.Connect("connection_succeeded", this, nameof(_OnRealMultiplayerConnectionSucceeded));
			realMultiplayerClient.Connect("connection_failed", this, nameof(_OnRealMultiplayerConnectionFailed));
			realMultiplayerClient.Connect("peer_connected", this, nameof(_OnRealMultiplayerPeerConnected));
			realMultiplayerClient.Connect("peer_disconnected", this, nameof(_OnRealMultiplayerPeerDisconnected));
			realMultiplayerClient.Connect("recieved_message", this, nameof(_OnRealMultiplayerReceivedMessage));
			// Intercept any RPC's sent locally.
			customPeer.Connect("packet_generated", this, nameof(_OnCustomPeerPacketGenerated));
		    }
		    void _OnRealMultiplayerConnectionSucceeded()
		    {
			// Once connection is formed, assign a peer id somehow. If the real transport
			// doesn't have a compatible id, you'll need to generate your own ids, and map
			// them to the ids used by the real transport (the same mapping should be used
			// by all peers).
			//
			// Also, if you want Godot to treat this peer as the "host" or "server" (per
			// `GetTree().IsNetworkServer()`) then use the peer id of 1.
			var myId = realMultiplayerClient.GetMyId();
			customPeer.Initialize(myId);
			customPeer.SetConnectionStatus(NetworkedMultiplayerCustom.CONNECTION_CONNECTED);
		    }
		    void _OnRealMultiplayerConnectionFailed()
		    {
			customPeer.SetConnectionStatus(NetworkedMultiplayerCustom.CONNECTION_DISCONNECTED);
		    }
		    void _OnRealMultiplayerPeerConnected(int peerId)
		    {
			// Let Godot know a peer connected. Again, you may need to map between Godot ids
			// and the ids used by the real multiplayer client.
			customPeer.EmitSignal("peer_connected", peerId);
		    }
		    void _OnRealMultiplayerPeerDisconnected(int peerId)
		    {
			// Same notes as above.
			customPeer.EmitSignal("peer_disconnected", peerId);
		    }
		    void _OnCustomPeerPacketGenerated(int peerId, byte[] buffer, NetworkedMultiplayerPeer.TransferModeEnum transferMode)
		    {
			// Send any packets generated locally (ex RPCs) to the requested peer
			// using the real multiplayer client.
			if (transferMode == NetworkedMultiplayerPeer.TransferModeEnum.Reliable)
			{
			    realMultiplayerClient.SendReliable(peerId, new RealPacket()
			    {
				fromPeerId = customPeer.GetNetworkUniqueId(),
				data = buffer
			    });
			}
			else
			{
			    realMultiplayerClient.SendUnreliable(peerId, new RealPacket()
			    {
				fromPeerId = customPeer.GetNetworkUniqueId(),
				data = buffer
			    });
			}
		    }
		    void _OnRealMultiplayerReceivedMessage(RealPacket message)
		    {
			// Take any packets we recieved from other peers, and deliver them locally.
			customPeer.DeliverPacket(message.data, message.fromPeerId);
		    }
		}
		[/csharp]
		[/codeblocks]
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="deliver_packet">
			<return type="void" />
			<argument index="0" name="buffer" type="PoolByteArray" />
			<argument index="1" name="from_peer_id" type="int" />
			<description>
				Deliver a packet to the local [MultiplayerAPI].
				When your script receives a packet from other peers over the network (originating from the [signal packet_generated] signal on the sending peer), passing it to this method will deliver it locally.
			</description>
		</method>
		<method name="initialize">
			<return type="void" />
			<argument index="0" name="self_peer_id" type="int" />
			<description>
				Initialize the peer with the given [code]self_peer_id[/code] (must be between 1 and 2147483647).
				Can only be called if the connection status is [constant NetworkedMultiplayerPeer.CONNECTION_CONNECTING]. See [method set_connection_status].
			</description>
		</method>
		<method name="set_connection_status">
			<return type="void" />
			<argument index="0" name="connection_status" type="int" enum="NetworkedMultiplayerPeer.ConnectionStatus" />
			<description>
				Set the state of the connection. See [enum NetworkedMultiplayerPeer.ConnectionStatus].
				This will emit the [signal NetworkedMultiplayerPeer.connection_succeeded], [signal NetworkedMultiplayerPeer.connection_failed] or [signal NetworkedMultiplayerPeer.server_disconnected] signals depending on the status and if the peer has the unique network id of [code]1[/code].
				You can only change to [constant NetworkedMultiplayerPeer.CONNECTION_CONNECTING] from [constant NetworkedMultiplayerPeer.CONNECTION_DISCONNECTED] and to [constant NetworkedMultiplayerPeer.CONNECTION_CONNECTED] from [constant NetworkedMultiplayerPeer.CONNECTION_CONNECTING].
			</description>
		</method>
		<method name="set_max_packet_size">
			<return type="void" />
			<argument index="0" name="max_packet_size" type="int" />
			<description>
				Set the max packet size that this peer can handle.
			</description>
		</method>
	</methods>
	<signals>
		<signal name="packet_generated">
			<argument index="0" name="peer_id" type="int" />
			<argument index="1" name="buffer" type="PoolByteArray" />
			<argument index="2" name="transfer_mode" type="int" />
			<description>
				Emitted when the local [MultiplayerAPI] generates a packet (e.g. when calling [method Node.rpc]).
				Your script should take this packet and send it to the requested peer over the network (which should call [method deliver_packet] with the data when it's received).
			</description>
		</signal>
	</signals>
	<constants>
	</constants>
</class>
